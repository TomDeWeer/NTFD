function [ ughostDiag, ughostOffdiag, ubValue, vghostDiag, vghostOffdiag, vbValue ] ...
    = mGhostTerms( casedef, faceIndex )
%GHOSTTERMS Gives the matrix elements for the boundary conditions.
% MOET EEN diag, offdiag en bvalue geven voor zowel ux als uy!!!
dom = casedef.dom;

% Checking which boundary the face belongs to
for randID = 1:length(casedef.BC)
    range = dom.getzone(casedef.BC{randID}.zoneID).range;
    if faceIndex >= range(1) && faceIndex <= range(end)
        id =  randID;
        break
    end
end
% Checking which BC applies at that boundary
BC = casedef.BC{id}.kind;
switch BC
    case 'Dirichlet'
        % Determining lambda using the anonymous function
        lambda = getLambda(dom,faceIndex);
        if isa(phi, 'function_handle')
            pos = dom.fCoord(:,faceIndex);
            [ubValue, vbValue] = du(pos(1),pos(2));
        else
            ubValue = du(1);
            vbValue = du(2);
        end
        
        % u
        ughostDiag = 1-lambda; 
        ughostOffdiag = lambda;
        ubValue = casedef.BC{id}.data.bcval(1);
        % v
        vghostDiag = 1-lambda; 
        vghostOffdiag = lambda;
        vbValue = casedef.BC{id}.data.bcval(2);
    case 'Neumann'
        ksi = dom.fXiMag(faceIndex);
        ughostDiag = 1/(ksi);
        ughostOffdiag = -1/(ksi);
        vghostDiag = 1/(ksi);
        vghostOffdiag = -1/(ksi);
        du = casedef.BC{id}.data.bcval;
        if isa(phi, 'function_handle')
            pos = dom.fCoord(:,faceIndex);
            [ubValue, vbValue] = du(pos(1),pos(2));
        else
            ubValue = du(1);
            vbValue = du(2);
        end
    otherwise
        disp('BC not found');
end
end

